#ifndef RPC_H // header guard
#define RPC_H

#include "base.h"
#include "exceptions.h"
#include "logger.h"

#include <functional>
#include <memory>
#include <mutex>
#include <string>
#include <vector>

#ifdef _3FD_MICROSOFT_RPC

#   define RPC_USE_NATIVE_WCHAR
#   include <rpc.h>
#   include <AuthZ.h>

#   define RPC_IMPL_SWITCH(PARAM1, PARAM2) PARAM1
#   define RPC_MS_ONLY(PARAM) PARAM
#   define RPC_DCE_ONLY(PARAM)
#   define rpc_strlen wcslen

    typedef RPC_STATUS rpc_status_t;
    typedef RPC_WSTR rpc_string_t;

#else // DCE RPC for POSIX:

#   include <dce/rpc.h>

#   define RPC_IMPL_SWITCH(PARAM1, PARAM2) PARAM2
#   define RPC_MS_ONLY(PARAM)
#   define RPC_DCE_ONLY(PARAM) PARAM
#   define rpc_strlen strlen
#   define RPC_S_OK 0

    typedef unsigned32 rpc_status_t;
    typedef unsigned_char_p_t rpc_string_t;

#endif

namespace _3fd
{
using std::string;

namespace rpc
{
    /// <summary>
    /// Enumerates the possible options for RPC transport.
    /// </summary>
    enum class ProtocolSequence
    {
#   ifdef _3FD_MICROSOFT_RPC
        Local,
#   endif
        TCP
    };

    /// <summary>
    /// Enumerates the possible options for authentication level.
    /// </summary>
    enum class AuthenticationLevel : uint32_t
    {
        None      = RPC_IMPL_SWITCH(RPC_C_AUTHN_LEVEL_NONE,          rpc_c_protect_level_none), // no authn security at all
        Integrity = RPC_IMPL_SWITCH(RPC_C_AUTHN_LEVEL_PKT_INTEGRITY, rpc_c_protect_level_pkt_integ),
        Privacy   = RPC_IMPL_SWITCH(RPC_C_AUTHN_LEVEL_PKT_PRIVACY,   rpc_c_protect_level_pkt_privacy)
    };

    /// <summary>
    /// Enumerates the possible options for authentication security (packages).
    /// </summary>
    enum class AuthenticationSecurity : unsigned long
    {
#   ifdef _3FD_MICROSOFT_RPC // Both client and server must on Windows:
        NTLM = RPC_C_AUTHN_WINNT, // Microsoft NT LAN Manager SSP
        TryKerberos = RPC_C_AUTHN_GSS_NEGOTIATE, // Microsoft Negotiate SSP
        RequireMutualAuthn = RPC_C_AUTHN_GSS_KERBEROS, // Microsoft Kerberos SSP (or NTLM with mutual authentication)
#   endif
        SecureChannel = RPC_IMPL_SWITCH(RPC_C_AUTHN_GSS_SCHANNEL, rpc_c_authn_schannel)
    };

    /// <summary>
    /// Enumerates the possible options for impersonation level.
    /// </summary>
    enum class ImpersonationLevel : unsigned long
    {
        Default = RPC_C_IMP_LEVEL_DEFAULT, // automatic
        Identify = RPC_C_IMP_LEVEL_IDENTIFY,
        Impersonate = RPC_C_IMP_LEVEL_IMPERSONATE,
        Delegate = RPC_C_IMP_LEVEL_DELEGATE
    };

    /// <summary>
    /// Holds a definition for a particular RPC interface implementation.
    /// </summary>
    struct RpcSrvObject
    {
        /// <summary>
        /// The UUID of the object, which is an external identifier
        /// exposed to clients. (This is not the interface UUID.)
        /// </summary>
        string uuid;

        /// <summary>
        /// The interface handle defined in the stub generated by MIDL compiler from IDL file.
        /// This handle internally defines the default EPV (when MIDL has been run with '/use_epv').
        /// </summary>
        RPC_IF_HANDLE interfaceHandle;

        /// <summary>
        /// The entry point vector. If this is null, then the default EPV supplied
        /// by the inteface handle is used.
        /// </summary>
        RPC_MGR_EPV *epv;

        RpcSrvObject(
            const string &p_uuid,
            RPC_IF_HANDLE p_interfaceHandle,
            RPC_MGR_EPV *p_epv = nullptr
        )
        :   uuid(p_uuid),
            interfaceHandle(p_interfaceHandle),
            epv(p_epv)
        {}
    };

    class RpcServerImpl;

    /// <summary>
    /// Represents the RPC server that runs inside the application process.
    /// </summary>
    class RpcServer : notcopiable
    {
    private:

        static std::unique_ptr<RpcServerImpl> uniqueObject;

        static std::mutex singletonAccessMutex;

        RpcServer() {}

    public:

        ~RpcServer() {}

        static void Initialize(
            ProtocolSequence protSeq,
            const string &serviceName,
            AuthenticationLevel authnLevel
        );

        static AuthenticationLevel GetRequiredAuthnLevel();

        static bool Start(const std::vector<RpcSrvObject> &objects);

        static bool Stop();

        static bool Resume();

        static bool Wait();

        static bool Finalize() noexcept;
    };

    struct CertInfo
    {

    };

    /// <summary>
    /// Implements an RPC client that provides an explicit binding handle
    /// to use as parameter for client stub code generated by the MIDL compiler.
    /// Client code is expected to derive from this class and call <see cref="RpcClient::GetBindingHandle"/>
    /// in order to obtain an explicit binding handle.
    /// </summary>
    class RpcClient : notcopiable
    {
    private:
            
        rpc_binding_handle_t m_bindingHandle;

    protected:

        /// <summary>
        /// Gets the binding handle.
        /// </summary>
        /// <returns>The explicit binding handle expected as parameter for RPC.</returns>
        rpc_binding_handle_t GetBindingHandle() const { return m_bindingHandle; }

    public:

        RpcClient(
            ProtocolSequence protSeq,
            const string &objUUID,
            const string &destination,
            AuthenticationLevel authnLevel = AuthenticationLevel::None,
            const string &endpoint = ""
        );

#   ifdef _3FD_MICROSOFT_RPC

        RpcClient(
            ProtocolSequence protSeq,
            const string &objUUID,
            const string &destination,
            const string &spn,
            AuthenticationLevel authnLevel = AuthenticationLevel::Integrity,
            AuthenticationSecurity authSec = AuthenticationSecurity::TryKerberos,
            ImpersonationLevel impLevel = ImpersonationLevel::Default,
            const string &endpoint = ""
        );

#   endif

        RpcClient(
            ProtocolSequence protSeq,
            const string &objUUID,
            const string &destination,
            const CertInfo &certInfoX509,
            AuthenticationLevel authnLevel = AuthenticationLevel::None,
            ImpersonationLevel impLevel = ImpersonationLevel::Default,
            const string &endpoint = ""
        );

        ~RpcClient();

        void ResetBindings();
    };

    /// <summary>
    /// Uses RAII to define a scope where impersonation takes place.
    /// </summary>
    class ScopedImpersonation : notcopiable
    {
    private:

        rpc_binding_handle_t m_clientBindingHandle;

    public:

        ScopedImpersonation(rpc_binding_handle_t clientBindingHandle);
        ~ScopedImpersonation();
    };

    /////////////////////////
    // Error Helpers
    /////////////////////////

    void ThrowIfError(rpc_status_t status, const char *message);

    void ThrowIfError(
        rpc_status_t status,
        const char *message,
        const string &details
    );

    void LogIfError(
        rpc_status_t status,
        const char *message,
        core::Logger::Priority prio
    ) noexcept;

    void LogIfError(
        rpc_status_t status,
        const char *message,
        const string &details,
        core::Logger::Priority prio
    ) noexcept;

}// end of namespace rpc
}// end of namespace _3fd

#endif // end of header guard
