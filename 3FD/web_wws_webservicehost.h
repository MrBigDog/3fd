#ifndef WEB_WWS_WEBSERVICEHOST_H // header guard
#define WEB_WWS_WEBSERVICEHOST_H

#include "web_wws_utils.h"

#include <codecvt>
#include <vector>
#include <map>
#include <mutex>
#include <memory>

namespace _3fd
{
	namespace web
	{
		namespace wws
		{
			// Callback type for code automatically generated by wsutil.exe
			template <typename BindingTemplateType, typename FuncTableStructType>
			using CallbackCreateWSEndpointImpl = HRESULT(*)(
				_In_opt_ BindingTemplateType* templateValue,
				_In_opt_ CONST WS_STRING* address,
				_In_opt_ FuncTableStructType* functionTable,
				_In_opt_ WS_SERVICE_SECURITY_CALLBACK authorizationCallback,
				_In_reads_opt_(endpointPropertyCount) WS_SERVICE_ENDPOINT_PROPERTY* endpointProperties,
				_In_ const ULONG endpointPropertyCount,
				_In_ WS_HEAP* heap,
				_Outptr_ WS_SERVICE_ENDPOINT** serviceEndpoint,
				_In_opt_ WS_ERROR* error);

			/// <summary>
			/// A template that performs some parameter translations needed to call automatically generated code.
			/// </summary>
			/// <param name="callback">
			/// A callback to the implmentation generated by wsutil.exe for endpoint creation.
			/// </param>
			/// <param name="address">The endpoint URL address.</param>
			/// <param name="functionTable">The function table (service contract).</param>
			/// <param name="endpointProps">The endpoint properties.</param>
			/// <param name="endpointPropsCount">The counting of endpoint properties.</param>
			/// <param name="heap">The heap to allocate memory from.</param>
			/// <param name="endpoint">Where to save the created endpoint.</param>
			/// <param name="err">Where to keep rich error information.</param>
			/// <returns>
			/// An HRESULT code, which is 'S_OK' when successful.
			/// </returns>
			template <typename BindingTemplateType, typename FuncTableStructType>
			HRESULT CreateWSEndpoint(
				void *callback,
				const string &address,
				void *functionTable,
				WS_SERVICE_ENDPOINT_PROPERTY *endpointProps,
				size_t endpointPropsCount,
				WSHeap &heap,
				WS_SERVICE_ENDPOINT **endpoint,
				WSError &err)
			{
				std::wstring_convert<std::codecvt_utf8<wchar_t>> transcoder;
				auto ucs2address = transcoder.from_bytes(address);

				auto wsaddr = heap.Alloc<WS_STRING>();
				wsaddr->length = ucs2address.length();
				wsaddr->chars = heap.Alloc<wchar_t>(ucs2address.length());
				memcpy(wsaddr->chars, ucs2address.data(), ucs2address.length() * sizeof ucs2address[0]);

				auto createEndpoint =
					static_cast<CallbackCreateWSEndpointImpl<BindingTemplateType, FuncTableStructType>> (callback);

				auto typedFuncTable = static_cast<FuncTableStructType *> (functionTable);

				return createEndpoint(
					nullptr,
					wsaddr,
					WS_HEAP_NEW(heap, FuncTableStructType, (*typedFuncTable)),
					nullptr,
					endpointProps,
					endpointPropsCount,
					heap.GetHandle(),
					endpoint,
					err.GetHandle()
				);
			}

			/* Callback type for template function that wraps code
			automatically generated by wsutil.exe */
			typedef HRESULT(*CallbackWrapperCreateWSEndpoint)(
				void *, // callback
				const string &, // address
				void *, // function table
				WS_SERVICE_ENDPOINT_PROPERTY *, // endpoint properties
				size_t, // endpoint properties count
				WSHeap &,
				WS_SERVICE_ENDPOINT **,
				WSError &);

			/// <summary>
			/// Contains associations of bindings to custom and
			/// automatically generated (by wstuil.exe) implementations.
			/// </summary>
			class ServiceBindings : notcopiable
			{
			public:

				/// <summary>
				/// Has the implementations for a service endpoint with a specific binding.
				/// </summary>
				struct Implementation
				{
					// The table of functions that implement the service contract
					void *functionTable;

					// The function generated by wsutil.exe for endpoint creation
					void *wsCallbackCreateEndpoint;

					// Wrapper for function that creates an endpoint
					CallbackWrapperCreateWSEndpoint createEndpoint;
				};

			private:

				/// <summary>
				/// Maps the binding name to the provided implementation.
				/// </summary>
				std::map<string, Implementation> m_bindToImpl;

			public:

				ServiceBindings() {}

				/// <summary>
				/// Initializes a new instance of the <see cref="ServiceBindings"/> struct using move semantics.
				/// </summary>
				/// <param name="ob">The object whose resources will be stolen.</param>
				ServiceBindings(ServiceBindings &&ob) :
					m_bindToImpl(std::move(m_bindToImpl))
				{}

				const Implementation *GetImplementation(const string &bindName) const;

				/// <summary>
				/// Maps the binding name to implementations
				/// for a service endpoint with such binding.
				/// </summary>
				/// <param name="bindName">Name of the binding.</param>
				/// <param name="functionTable">
				/// The table of functions that implement the service contract
				/// as specified in the binding.
				/// </param>
				/// <param name="callback">
				/// The function generated by wsutil.exe for endpoint creation
				/// </param>
				/// <remarks>
				/// The binding identifier is not fully qualified (by namespace) because this
				/// framework component assumes the programmer is using the target namespace
				/// of prefix 'tns' when declaring the bindings.
				/// </remarks>
				template <typename BindingTemplateType, typename FuncTableStructType>
				void MapBinding(const string &bindName,
							    FuncTableStructType *functionTable,
								CallbackCreateWSEndpointImpl<BindingTemplateType, FuncTableStructType> callback)
				{
					m_bindToImpl[bindName] =
						Implementation {
							functionTable,
							callback,
							&CreateWSEndpoint<BindingTemplateType, FuncTableStructType>
						};
				}
			};

			/// <summary>
			/// Contains several settings for a service endpoint.
			/// </summary>
			struct SvcEndpointsConfig : public ServiceBindings, notcopiable
			{
				unsigned int
					maxAcceptingChannels, // specifies the maximum number of concurrent channels service host will have actively accepting new connections for a given endpoint
					maxConcurrency; // specifies the maximum number of concurrent calls that would be serviced on a session based channel

				unsigned long
					//timeoutSend, // limits the amount of time (in milliseconds) that will be spent sending the HTTP headers and the bytes of the message
					//timeoutReceive, // limits the amount of time (in milliseconds) that will be spent receiving the the bytes of the message
					//timeoutDnsResolve, // limits the amount of time (in milliseconds) that will be spent resolving the DNS name
					timeoutClose; // limits the amount of time (in milliseconds) a service model will wait after 'Close' is called, and once the timeout expires, the host will abort

				/// <summary>
				/// Initializes a new instance of the <see cref="SvcEndpointsConfig"/> struct.
				/// Sets default values for configuration, except mapping of bindings to callbacks.
				/// </summary>
				SvcEndpointsConfig() : 
					maxAcceptingChannels(1),
					maxConcurrency(1),
					//timeoutSend(15000),
					//timeoutReceive(15000),
					//timeoutDnsResolve(60000),
					timeoutClose(0)
				{}
			};

			/// <summary>
			/// Holds key content for creation and descrition of a service endpoint.
			/// </summary>
			struct SvcEndpointInfo : notcopiable
			{
				string
					portName,
					bindingName,
					bindingNs,
					address;

				ServiceBindings::Implementation implementation;

				/// <summary>
				/// Initializes a new instance of the <see cref="SvcEndpointInfo"/> struct.
				/// </summary>
				SvcEndpointInfo()
				{
					implementation = { 0 };
				}

				/// <summary>
				/// Initializes a new instance of the <see cref="SvcEndpointInfo"/> struct
				/// using move semantics.
				/// </summary>
				/// <param name="ob">The object whose resources will be stolen.</param>
				SvcEndpointInfo(SvcEndpointInfo &&ob) :
					portName(std::move(ob.portName)),
					bindingName(std::move(ob.bindingName)),
					bindingNs(std::move(ob.bindingNs)),
					address(std::move(ob.address)),
					implementation(ob.implementation)
				{}
			};

			/// <summary>
			/// Implements the web service host infrastructure.
			/// </summary>
			class WebServiceHost : notcopiable
			{
			private:

				WS_SERVICE_HOST *m_wsSvcHostHandle;
				std::vector<char> m_wsdContentBuffer;
                string m_wsdTargetNs;
				string m_serviceName;
                std::vector<SvcEndpointInfo> m_endpointsInfo;
				std::mutex m_hostStateMutex;
				WSHeap m_svcHeap;

			public:

				WebServiceHost(size_t reservedMemory);

				~WebServiceHost();

				void Setup(
					const string &wsdFilePath,
					const SvcEndpointsConfig &config,
					bool enableMEX);

				void Open();
				bool Close();
				bool Abort();
			};

			//////////////////////
			// Utilities
			//////////////////////

			void SetSoapFault(
				core::IAppException &ex,
				const char *action,
				const WS_OPERATION_CONTEXT *wsOperContextHandle,
				WS_ERROR *wsErrorHandle);

		}// end of namespace wws
	}// end of namespace web
}// end of namespace _3fd

#endif // end of header guard