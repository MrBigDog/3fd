#ifndef RPC_H // header guard
#define RPC_H

#include <Poco\UUID.h>
#include <string>
#include <vector>
#include <rpc.h>

namespace _3fd
{
    using std::string;

    namespace rpc
    {
        using RpcInterfaceHandle = RPC_IF_HANDLE;

        // Provides necessary info to describe an interface
        class Interface
        {
        private:

            RpcInterfaceHandle m_handle; // This handle describes the interface and internally provides the function table. It is obtained from the source files generated by the IDL compiler.
            
            Poco::UUID m_uuid; // This UUID is assigned to uniquely identify this interface

            std::vector<Poco::UUID> m_objectsUUIDs; // A list of UUID's for objects implementing this interface

        public:

            Interface(RpcInterfaceHandle handle, const string &uuid);

            void AddObjectUUID(const string &uuid);

            RpcInterfaceHandle GetHandle() const { return  m_handle;  }

            const Poco::UUID &GetUUID() const { return m_uuid; }

            const std::vector<Poco::UUID> &GetObjectsUUIDs() const { return m_objectsUUIDs; }
        };

        class RpcServerImpl;

        // Represents the RPC server that runs inside the application process
        class RpcServer
        {
        private:

            static RpcServerImpl *uniqueObject;

            RpcServer();

        public:

            enum class ProtocolSequence { Local, TCP, UDP, HTTP };

            static RpcServer &GetInstance();
            
            ~RpcServer();

            void Start(ProtocolSequence protSeq, const std::vector<Interface> &interfaces);
        };

    }// end of namespace rpc
}// end of namespace _3fd

#endif // end of header guard
