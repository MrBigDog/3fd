#ifndef RPC_UTIL_IMPL_H // header guard
#define RPC_UTIL_IMPL_H

#include "rpc_helpers.h"

#include <string>
#include <memory>

#ifdef _3FD_MICROSOFT_RPC
#   include <NtDsAPI.h>
#   include <wincrypt.h>
#   include <schannel.h>
#endif

namespace _3fd
{
using std::string;

namespace rpc
{
    const char *ToString(ProtocolSequence protSeq);

    const char *ToString(AuthenticationLevel authnLevel);

    const char *ToString(ImpersonationLevel impersonationLevel);

    const char *ConvertAuthnSvcOptToString(unsigned long authnService);

#   ifdef _3FD_MICROSOFT_RPC

    void AppendSecQosOptsDescription(const RPC_SECURITY_QOS &secQOS, std::ostringstream &oss);

    const unsigned long UUID_VECTOR_MAX_SIZE(32);

    /// <summary>
    /// This is an improvised fix for UUID_VECTOR,
    /// that seems to be wrongly defined in RPC API.
    /// </summary>
    struct UuidVectorFix
    {
        unsigned long size;
        UUID *data[UUID_VECTOR_MAX_SIZE];
    };

    /// <summary>
    /// Simple wrapper for a vector of <see cref="UUID"/> structs.
    /// It uses RAII to guarantee deallocation upon scope end,
    /// not having to resort to smart pointers.
    /// </summary>
    class VectorOfUuids
    {
    private:

        std::vector<UUID *> m_ptrs2Uuids;

    public:

        VectorOfUuids() {}

        VectorOfUuids(VectorOfUuids &&ob)
            : m_ptrs2Uuids(std::move(ob.m_ptrs2Uuids)) {}

        VectorOfUuids &operator =(VectorOfUuids &&ob)
        {
            if (&ob != this)
                m_ptrs2Uuids = std::move(ob.m_ptrs2Uuids);

            return *this;
        }

        ~VectorOfUuids();

        size_t Size() const { return m_ptrs2Uuids.size(); }

        void Add(const UUID &uuid);

        UUID_VECTOR *CopyTo(UuidVectorFix &vec) noexcept;
    };

    /// <summary>
    /// RAII for Directory Service binding handle.
    /// </summary>
    struct DirSvcBinding
    {
        HANDLE handle;

        DirSvcBinding()
            : handle(nullptr) {}

        ~DirSvcBinding()
        {
            if (handle != nullptr)
                DsUnBindW(&handle);
        }
    };

    /// <summary>
    /// RAII for array of SPN's.
    /// </summary>
    struct ArrayOfSpn
    {
        DWORD size;
        LPWSTR *data;

        ArrayOfSpn()
            : size(0), data(nullptr) {}

        ~ArrayOfSpn()
        {
            if (data != nullptr)
                DsFreeSpnArrayW(size, data);
        }
    };

    bool DetectActiveDirectoryServices(DirSvcBinding &dirSvcBinding, bool isClient);

    /// <summary>
    /// Provides access to the system certificate store.
    /// </summary>
    class SystemCertificateStore : notcopiable
    {
    private:

        HCERTSTORE m_certStoreHandle;

    public:

        SystemCertificateStore(DWORD registryLocation, const string &storeName);

        ~SystemCertificateStore();

        PCCERT_CONTEXT FindCertBySubject(const string &certSubject) const;
    };

    // These wrappers make the porting from Microsoft RPC to DCE RPC a lot easier:

    void rpc_string_free(rpc_string_t *str, rpc_status_t *status)
    {
        *status = RpcStringFreeW(str);
    }

    void dce_error_inq_text(rpc_status_t errCode, rpc_string_t errText, rpc_status_t *status)
    {
        *status = DceErrorInqTextW(errCode, errText);
    }

    /// <summary>
    /// Wraps a credential for secure channel SSP, containing a X.509
    /// certificate from the store and using RAII to control reference
    /// count for the certificate
    /// </summary>
    class SChannelCredWrapper
    {
    private:

        SCHANNEL_CRED m_credStructure;

    public:

        SChannelCredWrapper(
            PCCERT_CONTEXT certCtxtHandle,
            bool strongerSec = false
        );

        SChannelCredWrapper(
            HCERTSTORE certStoreHandle,
            PCCERT_CONTEXT certCtxtHandle,
            bool strongerSec = false
        );

        ~SChannelCredWrapper();

        SCHANNEL_CRED *GetCredential() { return &m_credStructure; }
    };

#   else



#   endif

    /// <summary>
    /// RAII for RPC lib C-style strings.
    /// </summary>
    struct RpcString
    {
        rpc_string_t data;

        RpcString()
            : data(nullptr) {}

        ~RpcString()
        {
            if (data != nullptr)
            {
                CALL_STACK_TRACE;
                rpc_status_t status;
                rpc_string_free(&data, &status);
                LogIfError(status,
                    "Failed to release resources of string generated by RPC library",
                    core::Logger::PRIO_CRITICAL);
            }
        }
    };

}// end of namespace rpc
}// end of namespace _3fd

#endif // end of header guard
